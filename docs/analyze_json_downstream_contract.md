# Контракт сервиса анализа с downstream-записью

Этот документ описывает, какие данные сервис `/v1/analyze/json` принимает на вход
и что возвращает в ответ. Его можно передать команде, которая реализует запись
в БД или другой потребительский сервис.

## 1. Входные данные

Эндпоинт принимает `POST`-запрос с телом `AnalyzeFromJsonRequest`.

| Поле | Тип | Обязательность | Назначение |
| --- | --- | --- | --- |
| `text_par` | `string` | да | Исходный текст сайта. Перед отправкой желательно убрать управляющие символы и лишние пробелы. |
| `pars_id` | `int` | нет | Идентификатор строки `pars_site`. Используется в логах и возвращается в ответе. |
| `company_id` | `int` | нет | Логическое поле для расширенных логов. |
| `chat_model` | `string` | нет | Имя модели LLM. Если не заполнено, используется значение из настроек. |
| `embed_model` | `string` | нет | Модель эмбеддингов; по умолчанию берётся из настроек. |
| `goods_catalog` | `CatalogItemsPayload` | нет | Каталог товаров. Можно передать как массив `CatalogItem` или объект `{ "items": [...] }`. Каждому элементу разрешены вектора-строки, массивы чисел или объект `CatalogVector` с полями `values`/`literal`. |
| `equipment_catalog` | `CatalogItemsPayload` | нет | Каталог оборудования в том же формате, что и товары. |
| `return_prompt` | `bool` | нет | Вернуть ли промпт в ответе (по умолчанию `false`). |
| `return_answer_raw` | `bool` | нет | Вернуть ли сырое сообщение LLM в верхнем уровне ответа (по умолчанию `true`). Даже при выключенном флаге текст дублируется в `parsed.LLM_ANSWER` и `db_payload.llm_answer`. |

Определения типов можно посмотреть в коде схем: `AnalyzeFromJsonRequest`,
`CatalogItemsPayload`, `CatalogItem`, `CatalogVector`【F:app/api/schemas.py†L8-L66】.

Каталоги нормализуются helper-функцией `_catalog_items_to_dict`: она принимает
массивы, словари `{ "items": [...] }` и одиночные элементы, приводя их к списку
словари с ключами `id`, `name`, `vec`. Вектор поддерживает несколько вариантов:
строка в формате `pgvector`, массив чисел либо объект с полями `values` и
`literal`. При необходимости строковое представление генерируется автоматически.
См. `_normalize_catalog_vector` и `_catalog_items_to_dict`【F:app/api/handlers/analyze_json.py†L66-L126】.

## 2. Структура ответа

Ответ соответствует модели `AnalyzeFromJsonResponse`【F:app/api/schemas.py†L99-L114】.
Ключевые блоки:

### 2.1. Верхний уровень

| Поле | Описание |
| --- | --- |
| `pars_id` | Значение из запроса (если было передано). |
| `prompt`, `prompt_len` | Промпт и его длина. `prompt` присутствует только при `return_prompt=true`. |
| `answer_raw`, `answer_len` | Сырой ответ LLM (если разрешено) и количество символов. |
| `description` | Готовый итоговый дескрипшен. |
| `parsed` | Полностью распарсенный ответ модели, дополненный служебными полями (`PRODCLASS_TITLE`, диагностикой по PRODCLASS, списки для превью). |
| `prodclass` | Объект `ProdclassPayload` с выбранным классом, скором и источником оценки. |
| `description_vector` | Объект `VectorPayload` с вектором описания: числовое значение (`values`), строка (`literal`) и размерность (`dim`). |
| `goods_items`, `equipment_items` | Массивы `MatchedItemPayload` по товарам и оборудованию (см. ниже). Заглушки вроде «нет» или «—» автоматически отбрасываются. |
| `counts` | Служебные количества: сколько элементов пришло из LLM и сколько прошло матчинг. |
| `timings` | Метрики по этапам обработки в миллисекундах. |
| `catalogs` | Размеры переданных каталогов (`goods`, `equipment`). |
| `db_payload` | Готовая структура, предназначенная для записи в БД downstream-сервисом. |

Внутри словаря `parsed` помимо оригинальных секций ответа находятся служебные ключи:

* `PRODCLASS_SOURCE` — способ определения класса производства. Возможные значения: `model_reply` (LLM вернул корректный ID), `name_match` (ID восстановлен по тексту секции), `text_embedding_override` (LLM-ответ заменён на результат эмбеддингов) и `text_embedding_fallback` (ID целиком взят из эмбеддингов).
* `PRODCLASS_EMBED_GUESS`, `PRODCLASS_EMBED_GUESS_SCORE` — лучшая рекомендация эмбеддингов по тексту сайта и её скор. Эти поля помогают проанализировать, почему был выбран определённый класс.
* `GOODS_TYPE_SOURCE` — источник списка товаров (`GOODS_TYPE` из ответа LLM или резервный список из секции `GOODS`).

### 2.2. Структура `ProdclassPayload`

`ProdclassPayload` содержит:

* `id` — идентификатор класса из справочника `ib_prodclass`.
* `title` — человекочитаемое название (подставляется по ID).
* `score` — итоговый скор (0.00–1.00). Если модель не выдала значение,
  сервис пытается восстановить его по эмбеддингам. При недоступности эмбеддингов
  возвращается `0.0` с `score_source=not_available`.
* `score_source` — указывает, откуда взялся скор:
  * `model_reply` — LLM прислал готовое число.
  * `text_embedding_verify` — скор пересчитан эмбеддингами для проверки ответа LLM.
  * `text_embedding_override` — скор и ID целиком заменены на результат эмбеддинг-анализа.
  * `text_embedding_fallback` — ID выбран эмбеддингами из-за отсутствия валидного ответа LLM.
  * `fallback_embeddings` — скор восстановлен базовой проверкой «текст ↔ название класса» без кеша эмбеддингов.
  * `not_available` — скор не удалось определить (например, не задана модель эмбеддингов или расчёт завершился ошибкой). В этом случае текст причины приходит в `parsed.PRODCLASS_SCORE_ERROR`.
* `source` — способ выбора ID (см. значения в `PRODCLASS_SOURCE`).【F:app/api/handlers/analyze_json.py†L327-L334】

### 2.3. Структура `MatchedItemPayload`

Каждый элемент списка товаров или оборудования содержит:

* `text` — исходная строка из ответа LLM.
* `match_id` — ID найденного элемента каталога (или `null`, если порог не достигнут).
* `score` — косинусное сходство (0.00–1.00) при условии, что найден ID; иначе `null`.
* `vector` — объект `VectorPayload` с рассчитанным эмбеддингом элемента. Здесь
  всегда присутствует `literal` (строка вида `[0.1,0.2,...]`). Размерность выводится
  по длине массива `values` (если сохранены). Формирование происходит в
  `_matched_payload` и `_vector_payload`【F:app/api/handlers/analyze_json.py†L129-L166】.

### 2.4. Структура `db_payload`

Это основной блок, который downstream-сервис может использовать для записи в БД.
Он повторяет сущности из верхнего уровня и гарантирует наличие всех необходимых
полей.【F:app/api/handlers/analyze_json.py†L442-L481】

| Поле | Тип | Содержимое |
| --- | --- | --- |
| `description` | `string` | Итоговое описание. |
| `description_vector` | `VectorPayload` | Эмбеддинг описания. |
| `prodclass` | `ProdclassPayload` | Информация о классе. |
| `goods_types` | `MatchedItemPayload[]` | Сопоставленные товары. |
| `equipment` | `MatchedItemPayload[]` | Сопоставленное оборудование. |
| `llm_answer` | `string` или `null` | Полный ответ модели (всегда заполняется, даже если `answer_raw` скрыт). |

### 2.5. Пример ответа

Ниже приведён усечённый пример (без длинных векторов) для запроса с включёнными
каталогами и возвратом промпта:

```json
{
  "pars_id": 314159,
  "prompt_len": 8123,
  "answer_len": 612,
  "description": "ООО \"ТехПромЛайн\" проектирует...",
  "prodclass": {
    "id": 43,
    "title": "Предприятия сварочного производства и роботизированной сварки",
    "score": 0.93,
    "score_source": "model_reply",
    "source": "PRODCLASS"
  },
  "goods_items": [
    {
      "text": "Металлоконструкции сварные",
      "match_id": 101,
      "score": 0.88,
      "vector": {
        "dim": 1536,
        "literal": "[0.14,-0.03,0.22,...]"
      }
    }
  ],
  "equipment_items": [
    {
      "text": "Роботизированная линия сварки",
      "match_id": 11,
      "score": 0.91,
      "vector": {
        "dim": 1536,
        "literal": "[0.41,-0.07,0.33,...]"
      }
    }
  ],
  "db_payload": {
    "description": "ООО \"ТехПромЛайн\" проектирует...",
    "prodclass": { "id": 43, "score": 0.93, "title": "...", "score_source": "model_reply", "source": "PRODCLASS" },
    "llm_answer": "[DESCRIPTION]=[...]\n[PRODCLASS]=...",
    "goods_types": [ ... ],
    "equipment": [ ... ]
  }
}
```

Downstream-сервису достаточно сохранить содержимое `db_payload`. При этом
дополнительные поля (`counts`, `timings`, `parsed`) помогают отладить процесс и
могут логироваться или использоваться для мониторинга.

## 3. Правила обработки ошибок

* HTTP 400 — ошибки входных данных (пустой `text_par`, отсутствующие модели,
  неподдерживаемый формат каталога).
* HTTP 502 — ошибки от LLM или парсера ответа (пустой ответ модели, некорректная
  структура после парсинга).
* HTTP 500 — внутренние исключения.

Каждая ошибка сопровождается человекочитаемым `detail`.

## 4. Рекомендации для сервиса записи

1. Сохраняйте `llm_answer` как текст, чтобы можно было проанализировать
   расхождения и повторно воспроизвести ответ модели.
2. В `MatchedItemPayload.vector.literal` всегда лежит строка, которую можно
   напрямую привести к `vector`/`pgvector` в PostgreSQL (`CAST(:literal AS vector)`).
3. Если `match_id` равен `null`, элемент можно записать как новый или пропустить —
   логика остаётся на стороне downstream-сервиса.
4. Обращайте внимание на `counts`: если `goods_enriched` равно нулю при ненулевом
   `goods_source`, значит, порог сходства не был достигнут. Порог задаётся в коде
   (`MATCH_THRESHOLD_GOODS`/`MATCH_THRESHOLD_EQUIPMENT`) и сейчас равен 0.45/0.45
   соответственно.【F:app/services/analyzer.py†L16-L40】

Эти сведения дают полное представление о том, что именно отправляет сервис
анализа и какие форматы входных данных он поддерживает.

## Дополнительные поля ответа (стоимость и биллинг)

В `AnalyzeFromJsonResponse` добавлены необязательные поля:

- `request_cost: { model, input_tokens, cached_input_tokens, output_tokens, cost_usd } | null`
- `billing_summary: { currency, period_start, period_end, spent_usd, limit_usd, prepaid_credits_usd, remaining_usd } | null`

Это расширение обратно совместимо: существующие интеграции, которые игнорируют неизвестные поля, продолжат работать без изменений.
