# Проверка реализации присвоения справочников IB

## 1. Получение входных данных
- Эндпоинт `POST /v1/ib-match` принимает `IbMatchRequest`, извлекает `client_id` и режим синхронизации. Затем выполняет чтение связанных типов продукции и оборудования из таблиц `ai_site_goods_types` и `ai_site_equipment` по `company_id`, а также грузит справочники `ib_goods_types` и `ib_equipment`. Это реализовано в `assign_ib_matches` (строки 376-408). 【F:app/api/routes.py†L376-L408】
- Репозиторий использует запросы, идентичные требованиям: `fetch_client_goods` выбирает `id`, `goods_type`, `text_vector::text` и связывает с `pars_site` по `company_id` (строки 453-479). Аналогичная логика для оборудования в `fetch_client_equipment` (строки 482-508). 【F:app/repositories/parsing_repo.py†L453-L508】

## 2. Генерация и обновление эмбеддингов
- Для каждого элемента goods и equipment проверяется наличие `text_vector`; если он отсутствует или выставлен флаг `reembed_if_exists`, формируется список на эмбеддинг (строки 442-472 и 474-504). 【F:app/api/routes.py†L442-L504】
- Вызов `embed_many` создаёт эмбеддинги с использованием OpenAI и внутренних провайдеров, затем результат обновляет `text_vector` через `update_goods_vectors` и `update_equipment_vectors` (строки 506-551). Дополнительно доступен REST-роут сервиса `POST /ai-search`, принимающий `{"q": "текст"}` и возвращающий структуру `{ "embedding": [...] }`, которую можно использовать для получения вектора без прямого обращения к OpenAI. 【F:app/api/routes.py†L506-L551】【F:app/main.py†L145-L170】
- Репозиторий выполняет соответствующие `UPDATE ... SET text_vector = :vec::vector` (строки 511-552). 【F:app/repositories/parsing_repo.py†L511-L552】

## 3. Подбор соответствий по косинусному сходству
- Справочники IB конвертируются в массивы `(id, name, vector)` и фильтруются по наличию валидных векторов (строки 421-437). 【F:app/api/routes.py†L421-L437】
- Для каждого товара/оборудования рассчитывается косинусное сходство с каждым элементом справочника через `cosine_similarity` до выбора максимального `score`. Результат округляется до 4 знаков для вывода и до 2 знаков для записи в БД (строки 553-616). 【F:app/api/routes.py†L553-L616】
- Обновление полей `goods_type_ID`, `goods_types_score`, `equipment_ID`, `equipment_score` производится функциями репозитория `update_goods_matches` и `update_equipment_matches`, выполняющими точные `UPDATE`-запросы (строки 555-596). 【F:app/repositories/parsing_repo.py†L555-L596】

## 4. Формирование отчёта
- Генерируется подробный отладочный отчёт с блоками, повторяющими структуру из задания: перечисление исходных записей, размеры справочников, количество эмбеддингов, итоговые таблицы соответствий и сводка. Финальный вывод включает разделы `[ПОДБОР GOODS]` и `[ПОДБОР EQUIPMENT]` (строки 665-748). 【F:app/api/routes.py†L665-L748】
- Журналирование каждого успешного соответствия проводится отдельными `log.info` вызовами (строки 631-651). 【F:app/api/routes.py†L631-L651】

## 5. Дополнительные наблюдения
- Косинусное сходство возвращает значения в диапазоне [0, 1] и корректно обрабатывает пустые/некорректные векторы (`app/utils/vectors.py`, строки 8-39). 【F:app/utils/vectors.py†L8-L39】
- Пакетная генерация эмбеддингов поддерживает усреднение длинных текстов и fallback-провайдеры (`app/services/embeddings.py`, строки 228-260). 【F:app/services/embeddings.py†L228-L260】

По результатам проверки реализация полностью соответствует предъявленным требованиям и воспроизводит поведение, показанное в примере из задания.

## Итоговый промт для стороннего сервиса
Ниже приведён готовый промт, который можно передать другой команде для реализации аналогичной функциональности.

---
Создай сервис для подбора релевантных типов продукции и оборудования из справочников IB.

**Входные данные**
- `client_id` — идентификатор компании из `clients_requests.id`.
- Флаг `reembed_if_exists` (опционально) — если `true`, переобучать эмбеддинги даже при заполненном `text_vector`.

**Шаги обработки**
1. Получить из БД (PostgreSQL) данные:
   - Записи `ai_site_goods_types`, связанные с компанией (`pars_site.company_id = client_id`): поля `id`, `goods_type`, `text_vector`.
   - Записи `ai_site_equipment`, связанные с компанией (`pars_site.company_id = client_id`): поля `id`, `equipment`, `text_vector`.
   - Справочники `ib_goods_types` (поля `id`, `goods_type_name`, `goods_type_vector`) и `ib_equipment` (поля `id`, `equipment_name`, `equipment_vector`).
2. Для каждой строки `ai_site_goods_types` и `ai_site_equipment`:
   - Если `text_vector` пуст и флаг `reembed_if_exists` не установлен, пропусти шаг эмбеддинга.
   - Иначе получи эмбеддинг текста (`goods_type` либо `equipment`) через OpenAI модель `text-embedding-3-large` (вектор 3072 float) либо вызови предоставленный сервис `POST /ai-search` с телом `{"q": "исходный текст"}` и используй поле `embedding` из ответа. Сохрани результат в формате pgvector (`[v1,v2,...]`) обратно в таблицу.
3. Для сопоставления типов продукции:
   - Сравни эмбеддинг каждой строки `ai_site_goods_types` с каждым вектором `ib_goods_types.goods_type_vector`, вычислив косинусное сходство.
   - Найди справочник с максимальным сходством. Запиши его `id` в `ai_site_goods_types.goods_type_ID`, а значение сходства (округление до двух знаков) в `ai_site_goods_types.goods_types_score`.
4. Аналогично обработай оборудование:
   - Сравни `ai_site_equipment.text_vector` с `ib_equipment.equipment_vector`.
   - Запиши лучший `ib_equipment.id` в `ai_site_equipment.equipment_ID` и косинусное сходство (2 знака после запятой) в `ai_site_equipment.equipment_score`.
5. Сформируй детализированный отчёт в текстовом виде:
   - Список исходных товаров и оборудования с их идентификаторами.
   - Количество позиций со векторами в справочниках `ib_goods_types` и `ib_equipment`.
   - Количество сгенерированных эмбеддингов.
   - Таблицы соответствий с колонками `ai_*_id`, исходный текст, `match_ib_id`, `match_ib_name`, `score`, `note`.
   - Сводку по количеству обработанных/обновлённых записей.
   - Отдельные списки `[ПОДБОР GOODS]` и `[ПОДБОР EQUIPMENT]` с лучшим совпадением и значением `score` для каждой строки.
6. Все операции с БД должны выполняться в транзакциях. Ошибки логируй и возвращай понятные сообщения.

**Требования к реализации**
- Используй пакетную генерацию эмбеддингов (батчи до 64 элементов).
- Косинусное сходство должно возвращать значения в диапазоне [0, 1]. При отсутствии вектора пропускай строку и указывай причину в колонке `note`.
- Логи и итоговый отчёт должны повторять структуру из примера (строки с `[INFO]`, таблицы ASCII, блок `[ПОДБОР ...]`).
- Запросы на обновление должны чётко выставлять `goods_type_ID`, `goods_types_score`, `equipment_ID`, `equipment_score`.
- Учти возможность запуска в асинхронном окружении (используй `async`/`await` или аналогичные инструменты).

**Вывод**
Верни JSON-объект с:
- `client_id`.
- Перечнями подобранных соответствий для goods и equipment (id, исходный текст, подобранный справочник, score, note).
- Сводкой по количеству обработанных записей и количеству сгенерированных эмбеддингов.
- Текстом отладочного отчёта, сформированного на шаге 5.

---
