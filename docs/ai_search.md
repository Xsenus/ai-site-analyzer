# AI Search: получение эмбеддингов и fallback-ответов

Эндпоинт `/api/ai-search` предоставляет унифицированный способ получать
эмбеддинги текстов или, если вектор не удалось построить, вернуть пустые
результаты, которые downstream-сервис может заменить собственной логикой
поиска/ранжирования. Обработчик реализован в `app/routers/ai_search.py` и
использует внутренний провайдер эмбеддингов с fallback на OpenAI.

## Когда использовать

- Нужен быстрый способ получить вектор текста без прямого обращения к OpenAI.
- Требуется централизованный rate limit и нормализация входных строк перед
  запросом к внешнему провайдеру.
- Необходимо безопасно обрабатывать недоступность эмбеддингов, продолжая
  работу с пустыми результатами (например, чтобы не блокировать пайплайн).

## Формат запроса

`POST /api/ai-search`

```json
{
  "q": "Заготовки из алюминия и токарные работы"
}
```

- Обязательное поле `q` — текст для расчёта эмбеддинга. Обработчик выполняет
  лёгкую нормализацию (trim) и отклоняет пустые строки.
- Заголовки: `Content-Type: application/json`. Авторизация при необходимости
  настраивается на уровне FastAPI/ingress.

## Формат ответа

Успешный ответ (эмбеддинг получен):

```json
{
  "embedding": [0.12, -0.04, 0.33, ...]
}
```

Fallback-ответ (эмбеддинг недоступен):

```json
{
  "ids": {"goods": [], "equipment": [], "prodclasses": []}
}
```

- Вектор возвращается в виде массива чисел фиксированной длины `VECTOR_DIM`.
  Значение можно использовать как есть или конвертировать в pgvector.
- Если вектор не удалось получить (нет ключа OpenAI, внутренний сервис
  недоступен, таймаут), обработчик возвращает пустые коллекции ID/списков.
  Здесь можно внедрить собственную логику ранжирования вместо заглушки.

## Ограничения и таймауты

- **Rate limit.** Лимитер sliding window ограничивает число запросов в минуту по
  IP (`AI_SEARCH_RATE_LIMIT_PER_MIN`). При превышении вернётся `429 Too Many
  Requests`.
- **Таймаут.** Весь запрос ограничен `AI_SEARCH_TIMEOUT` секунд. При превышении
  возвращается `500 timeout` с телом `{ "error": "timeout" }`.
- **Валидация.** Пустые строки отклоняются с `400 q is required`. Некорректные
  ответы внутреннего сервиса или OpenAI приводят к `500 internal error`.

## Поведение под капотом

1. **Нормализация.** Строка `q` очищается от крайних пробелов и логируется в
   усечённом виде.
2. **Попытка №1 — внутренний провайдер.** Если задан `INTERNAL_EMBED_URL`, сервис
   выполняет `POST` `{ "text": q }` и ожидает `{"embedding": [...]}`.
3. **Попытка №2 — OpenAI.** При наличии `OPENAI_API_KEY` текст режется на чанки,
   вызывается `/v1/embeddings`, результаты усредняются. Итоговый вектор
   проверяется на корректную размерность (`VECTOR_DIM`).
4. **Fallback.** Если обе попытки не дали валидный вектор, возвращаются пустые
   ID-коллекции. Этот блок можно расширить собственной реализацией поиска.

## Настройка через переменные окружения

| Переменная | Назначение |
| --- | --- |
| `INTERNAL_EMBED_URL` | URL собственного сервиса эмбеддингов. Если не задан, сразу используется OpenAI. |
| `INTERNAL_EMBED_TIMEOUT` | Таймаут запроса к внутреннему провайдеру (секунды). |
| `OPENAI_API_KEY` | Ключ OpenAI для fallback. Если отсутствует, OpenAI не вызывается. |
| `OPENAI_EMBED_MODEL` / `EMBED_MODEL` | Имя модели эмбеддингов OpenAI (по умолчанию `text-embedding-3-large`). |
| `VECTOR_DIM` | Ожидаемая размерность эмбеддинга для валидации ответа. |
| `AI_SEARCH_TIMEOUT` | Максимальная длительность обработки одного запроса. |
| `AI_SEARCH_RATE_LIMIT_PER_MIN` | Количество запросов в минуту на один IP. |
| `EMBED_BATCH_SIZE`, `EMBED_MAX_CHARS` | Параметры нарезки длинных текстов на чанки для OpenAI. |

## Пример интеграции

```bash
curl -X POST "https://your-host/api/ai-search" \
     -H "Content-Type: application/json" \
     -d '{"q": "Буровые установки для нефтегазовой отрасли"}'
```

- При успехе получите массив `embedding`.
- При ошибке или недоступности провайдеров получите `ids` с пустыми массивами или
  сообщение об ошибке (`429`/`500`).

## Что логируется

- IP клиента и усечённый текст запроса (`q`).
- Остаток лимита запросов, итоговый тип ответа (embedding/ids), длительность
  обработки в миллисекундах.
- Детали исключений для таймаутов, ошибок валидации и неожиданных ситуаций.
